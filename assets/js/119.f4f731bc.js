(window.webpackJsonp=window.webpackJsonp||[]).push([[119],{569:function(v,t,e){"use strict";e.r(t);var s=e(44),o=Object(s.a)({},(function(){var v=this,t=v.$createElement,e=v._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"vue中的v-if和v-show的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue中的v-if和v-show的区别"}},[v._v("#")]),v._v(" Vue中的v-if和v-show的区别")]),v._v(" "),e("h3",{attrs:{id:"解答"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解答"}},[v._v("#")]),v._v(" 解答")]),v._v(" "),e("p",[e("code",[v._v("v-if")]),v._v(" 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。")]),v._v(" "),e("p",[e("code",[v._v("v-if")]),v._v(" 也是"),e("strong",[v._v("惰性的")]),v._v("（*：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。")]),v._v(" "),e("p",[v._v("相比之下，"),e("code",[v._v("v-show")]),v._v(" 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。")]),v._v(" "),e("p",[v._v("一般来说，"),e("code",[v._v("v-if")]),v._v("有更高的切换开销，而 "),e("code",[v._v("v-show")]),v._v(" 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 "),e("code",[v._v("v-show")]),v._v(" 较好；如果在运行时条件很少改变，则使用 v-if 较好。")])])}),[],!1,null,null,null);t.default=o.exports}}]);