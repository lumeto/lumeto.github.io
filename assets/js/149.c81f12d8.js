(window.webpackJsonp=window.webpackJsonp||[]).push([[149],{599:function(t,e,a){"use strict";a.r(e);var c=a(44),s=Object(c.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"nexttick实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick实现原理"}},[t._v("#")]),t._v(" nextTick实现原理")]),t._v(" "),a("h3",{attrs:{id:"什么是nexttick"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是nexttick"}},[t._v("#")]),t._v(" 什么是nextTick")]),t._v(" "),a("p",[a("code",[t._v("nextTick")]),t._v("有两种，一种是全局API——"),a("code",[t._v("Vue.nextTick")]),t._v("，另一种是实例方法/生命周期——"),a("code",[t._v("vm.$nextTick")]),t._v("。")]),t._v(" "),a("p",[t._v("二者的作用是一样的，即将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。")]),t._v(" "),a("p",[t._v("不同的是实例方法"),a("code",[t._v("vm.$nextTick")]),t._v("会自动将回调内部的this绑定到当前vue实例。")]),t._v(" "),a("h3",{attrs:{id:"nexttick原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick原理"}},[t._v("#")]),t._v(" nextTick原理")]),t._v(" "),a("p",[t._v("Vue在更新DOM是异步执行的。")]),t._v(" "),a("p",[t._v("只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。")]),t._v(" "),a("p",[t._v("如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。")]),t._v(" "),a("p",[t._v("然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。")]),t._v(" "),a("h3",{attrs:{id:"nexttick的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nexttick的实现"}},[t._v("#")]),t._v(" nextTick的实现")]),t._v(" "),a("ol",[a("li",[t._v("简单来说，首先，Vue 用一个 callbacks 数组存放待执行的 callback 函数，每当使用Vue.nextTick或者vm.$nextTick时，就会将callback push 到 callbacks数组中。")]),t._v(" "),a("li",[t._v("接下来， Vue 声明了一个 flushCallbacks 函数，这个函数会取出（清空） callbacks 数组中所有的 callback 函数并执行。")]),t._v(" "),a("li",[t._v("然后 Vue 会尝试把 flushCallbacks 变成一个 microtask 或者 task 来执行。具体是 microtask 还是 task 得看 Vue 当前运行在什么环境。")])])])}),[],!1,null,null,null);e.default=s.exports}}]);