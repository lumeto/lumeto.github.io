(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{600:function(t,a,e){"use strict";e.r(a);var o=e(44),n=Object(o.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"ajax请求放在哪个生命周期中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ajax请求放在哪个生命周期中"}},[t._v("#")]),t._v(" ajax请求放在哪个生命周期中")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),e("p",[t._v("答案： mounted 中")])]),t._v(" "),e("p",[t._v("那为什么不在 created 里去发ajax？created 可是比 mounted 更早调用啊，更早调用意味着更早返回结果，那样性能不是更高？")]),t._v(" "),e("p",[t._v("首先，一个组件的 created 比 mounted 也早调用不了几微秒，性能没啥提高")]),t._v(" "),e("p",[t._v("而且，等到异步渲染开启的时候，created 就可能被中途打断，中断之后渲染又要重做一遍，想一想，在 created 中做ajax调用，代码里看到只有调用一次，但是实际上可能调用 N 多次，这明显不合适。")]),t._v(" "),e("p",[t._v("相反，若把发ajax 放在 mounted，因为 mounted 在第二阶段，所以绝对不会多次重复调用，这才是ajax合适的位置")]),t._v(" "),e("p",[t._v("在created的时候，视图中的dom并没有被渲染出来，所以此时如果直接去操作dom节点，无法找到相关元素")]),t._v(" "),e("p",[t._v("在mounted中，由于此时的dom元素已经渲染出来了，所以可以直接使用dom节点。\n一般情况下，都放在mounted中，保证逻辑的统一性。因为生命周期是同步执行的，ajax是异步执行的")]),t._v(" "),e("p",[t._v("服务端渲染不支持mounted方法，所以在服务端渲染的情况下统一放在created中")])])}),[],!1,null,null,null);a.default=n.exports}}]);