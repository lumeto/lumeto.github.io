(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{506:function(t,v,_){"use strict";_.r(v);var s=_(44),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"http-和-https"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-和-https"}},[t._v("#")]),t._v(" HTTP 和 HTTPS")]),t._v(" "),_("h3",{attrs:{id:"http-和-https-的基本概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-和-https-的基本概念"}},[t._v("#")]),t._v(" http 和 https 的基本概念")]),t._v(" "),_("p",[t._v("http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。")]),t._v(" "),_("p",[t._v("https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。")]),t._v(" "),_("h3",{attrs:{id:"http-和-https-的区别及优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-和-https-的区别及优缺点"}},[t._v("#")]),t._v(" http 和 https 的区别及优缺点？")]),t._v(" "),_("ul",[_("li",[t._v("http 是超文本传输协议，信息是明文传输，HTTPS 协议要比 http 协议安全，https 是具有安全性的 ssl 加密传输协议，可防止数据在传输过程中被窃取、改变，确保数据的完整性(当然这种安全性并非绝对的，对于更深入的 Web 安全问题，此处暂且不表)。")]),t._v(" "),_("li",[t._v("http 协议的默认端口为 80，https 的默认端口为 443。")]),t._v(" "),_("li",[t._v("http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。")]),t._v(" "),_("li",[t._v("https 缓存不如 http 高效，会增加数据开销。")]),t._v(" "),_("li",[t._v("Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。")]),t._v(" "),_("li",[t._v("SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。")])]),t._v(" "),_("h3",{attrs:{id:"https-协议的工作原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#https-协议的工作原理"}},[t._v("#")]),t._v(" https 协议的工作原理")]),t._v(" "),_("p",[t._v("客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：")]),t._v(" "),_("ol",[_("li",[t._v("客户端使用 https url 访问服务器，则要求 web 服务器建立 ssl 链接。")]),t._v(" "),_("li",[t._v("web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），传输给客户端。")]),t._v(" "),_("li",[t._v("客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。")]),t._v(" "),_("li",[t._v("客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。")]),t._v(" "),_("li",[t._v("web 服务器通过自己的私钥解密出会话密钥。")]),t._v(" "),_("li",[t._v("web 服务器通过会话密钥加密与客户端之间的通信。")])]),t._v(" "),_("h2",{attrs:{id:"tcp三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[t._v("#")]),t._v(" TCP三次握手")]),t._v(" "),_("ol",[_("li",[t._v("第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。")]),t._v(" "),_("li",[t._v("第二次握手：服务器收到syn包并确认客户的SYN（ack=j+1），同时也发送一个自己的SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；")]),t._v(" "),_("li",[t._v("第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。")])]),t._v(" "),_("blockquote",[_("p",[t._v("握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。")])]),t._v(" "),_("h2",{attrs:{id:"tcp-四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-四次挥手"}},[t._v("#")]),t._v(" TCP 四次挥手")]),t._v(" "),_("ol",[_("li",[t._v("客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。")]),t._v(" "),_("li",[t._v("服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。")]),t._v(" "),_("li",[t._v("客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。")]),t._v(" "),_("li",[t._v("服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。")]),t._v(" "),_("li",[t._v("客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。")]),t._v(" "),_("li",[t._v("服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。")])]),t._v(" "),_("h2",{attrs:{id:"tcp-ip-如何保证数据包传输的有序可靠"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip-如何保证数据包传输的有序可靠"}},[t._v("#")]),t._v(" TCP/IP / 如何保证数据包传输的有序可靠？")]),t._v(" "),_("p",[t._v("对字节流分段并进行编号然后"),_("code",[t._v("通过 ACK 回复")]),t._v("和"),_("code",[t._v("超时重发")]),t._v("这两个机制来保证。")]),t._v(" "),_("ol",[_("li",[t._v("为了保证数据包的可靠传递，发送方必须把已发送的数据包保留在缓冲区；")]),t._v(" "),_("li",[t._v("并为每个已发送的数据包启动一个超时定时器；")]),t._v(" "),_("li",[t._v("如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占用的缓冲区;")]),t._v(" "),_("li",[t._v("否则，重传该数据包，直到收到应答或重传次数超过规定的最大次数为止。")]),t._v(" "),_("li",[t._v("接收方收到数据包后，先进行CRC校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可方在数据包中捎带过去。")])]),t._v(" "),_("h2",{attrs:{id:"tcp和udp的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别"}},[t._v("#")]),t._v(" TCP和UDP的区别")]),t._v(" "),_("ol",[_("li",[t._v("TCP是面向"),_("code",[t._v("链接")]),t._v("的，而UDP是面向无连接的。")]),t._v(" "),_("li",[t._v("TCP仅支持"),_("code",[t._v("单播传输")]),t._v("，UDP 提供了单播，多播，广播的功能。")]),t._v(" "),_("li",[t._v("TCP的三次握手保证了连接的"),_("code",[t._v("可靠性")]),t._v("; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。")]),t._v(" "),_("li",[t._v("UDP的头部开销比TCP的更小，数据"),_("code",[t._v("传输速率更高")]),t._v("，"),_("code",[t._v("实时性更好")]),t._v("。")])]),t._v(" "),_("h2",{attrs:{id:"http-请求跨域问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#http-请求跨域问题"}},[t._v("#")]),t._v(" HTTP 请求跨域问题")]),t._v(" "),_("h3",{attrs:{id:"跨域的原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跨域的原理"}},[t._v("#")]),t._v(" 跨域的原理")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("跨域")]),t._v("，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。")]),t._v(" "),_("li",[_("strong",[t._v("同源策略")]),t._v(",是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。")]),t._v(" "),_("li",[_("strong",[t._v("跨域原理")]),t._v("，即是通过各种方式，避开浏览器的安全限制。")])]),t._v(" "),_("h3",{attrs:{id:"解决方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),_("p",[t._v("最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("JSONP：")]),t._v(" "),_("p",[t._v("ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。")]),t._v(" "),_("p",[_("strong",[t._v("步骤：")])]),t._v(" "),_("ol",[_("li",[t._v("去创建一个script标签")]),t._v(" "),_("li",[t._v("script的src属性设置接口地址")]),t._v(" "),_("li",[t._v("接口参数，必须要带一个自定义函数名，要不然后台无法返回数据")]),t._v(" "),_("li",[t._v("通过定义函数名去接受返回的数据")])]),t._v(" "),_("p",[_("strong",[t._v("JSONP 的缺点:")])]),t._v(" "),_("p",[t._v("JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。")])]),t._v(" "),_("li",[_("p",[t._v("document.domain 基础域名相同 子域名不同")])]),t._v(" "),_("li",[_("p",[t._v("window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name")])]),t._v(" "),_("li",[_("p",[t._v("CORS CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求")])]),t._v(" "),_("li",[_("p",[t._v("proxy代理 目前常用方式,通过服务器设置代理")])]),t._v(" "),_("li",[_("p",[t._v("window.postMessage() 利用h5新特性window.postMessage()")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);