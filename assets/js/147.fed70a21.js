(window.webpackJsonp=window.webpackJsonp||[]).push([[147],{598:function(t,e,a){"use strict";a.r(e);var r=a(44),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"为何vue采用异步渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为何vue采用异步渲染"}},[t._v("#")]),t._v(" 为何Vue采用异步渲染")]),t._v(" "),a("h3",{attrs:{id:"原因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原因"}},[t._v("#")]),t._v(" 原因")]),t._v(" "),a("p",[t._v("Vue中的DOM操作都是异步执行，个人觉得原因有以下几点：")]),t._v(" "),a("ul",[a("li",[t._v("为了避免频繁操作DOM造成的性能消耗，如果每次数据发生变化都立即更新DOM的话，会造成频繁操作DOM。")]),t._v(" "),a("li",[t._v("避免重复的DOM操作，如果同一个 watcher 被多次触发，只会被推入到队列中一次。")])]),t._v(" "),a("h3",{attrs:{id:"实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),a("p",[t._v("只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。 如果同一个 watcher 被多次触发，只会被推入到队列中一次。 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。 然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。 Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver和setImmediate，如果执行环境不支持，则会采用setTimeout(fn, 0)代替。")])])}),[],!1,null,null,null);e.default=s.exports}}]);