## Vue的优点
- 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb 
- 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习
- 双向数据绑定： 在数据操作方面更为简单
- 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作
- 运行速度更快：相比较于 react 而言，同样是操作虚拟 dom ，就性能而言， vue 存在很大的优势

## 说说你对SPA单页面的理解，它的优缺点分别是什么？
**什么事spa单页面**

- SPA（ single page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS
- 一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转
- 而页面的变化是利用路由机制实现 HTML 内容的变换，避免页面的重新加载

**优点**

- 用户体验好，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染
- 减少了不必要的跳转和重复渲染，这样相对减轻了服务器的压力
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理

**缺点**

- 初次加载耗时多
- 不能使用浏览器的前进后退功能，由于单页应用在一个页面中显示所有的内容，所以，无法前进后退
- 不利于搜索引擎检索：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势

## SPA首屏加载速度慢的怎么解决？
首屏时间（First Contentful Paint），指的是浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间，此时整个网页不一定要全部渲染完成，但需要展示当前视窗需要的内容

**加载慢的原因**

- 网络延时问题
- 资源文件体积是否过大
- 资源是否重复发送请求去加载了
- 加载脚本的时候，渲染内容堵塞了

**常见的几种SPA首屏优化方式**

- 减小入口文件积
- 静态资源本地缓存
- UI框架按需加载
- 图片资源的压缩
- 组件重复打包
- 开启GZip压缩
- 使用SSR


## Vue初始化过程中（new Vue(options)）都做了什么？
- 处理组件配置项；初始化根组件时进行了选项合并操作，将全局配置合并到根组件的局部配置上；初始化每个子组件时做了一些性能优化，将组件配置对象上的一些深层次属性放到 vm.$options 选项中，以提高代码的执行效率
- 初始化组件实例的关系属性，比如 p a r e n t 、 parent、parent、children、r o o t 、 root、root、refs 等
- 处理自定义事件
- 调用 beforeCreate 钩子函数
- 初始化组件的 inject 配置项，得到 `ret[key] = val` 形式的配置对象，然后对该配置对象进行响应式处理，并代理每个 key 到 vm 实例上
- 数据响应式，处理 props、methods、data、computed、watch 等选项
- 解析组件配置项上的 provide 对象，将其挂载到 vm._provided 属性上
- 调用 created 钩子函数
- 如果发现配置项上有 el 选项，则自动调用 $mount 方法，也就是说有了 el 选项，就不需要再手动调用 $mount 方法，反之，没提供 el 选项则必须调用 $mount
- 接下来则进入挂载阶段

## 对MVVM的理解？
- MVVM 由 Model、View、ViewModel 三部分构成，Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来；ViewModel 是一个同步View 和 Model的对象

- 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上

- ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM， 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理


## Vue数据双向绑定原理
实现mvvm的数据双向绑定，是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来给各个属性添加setter，getter并劫持监听，在数据变动时发布消息给订阅者，触发相应的监听回调。就必须要实现以下几点：

1. 实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
2. 实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
3. 实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图


## Vue的响应式原理
什么是响应式，也即是说，数据发生改变的时候，视图会重新渲染，匹配更新为最新的值

Object.defineProperty 为对象中的每一个属性，设置 get 和 set 方法，每个声明的属性，都会有一个 专属的依赖收集器 subs，当页面使用到 某个属性时，触发 ObjectdefineProperty - get函数，页面的 watcher 就会被 放到 属性的依赖收集器 subs 中，在 数据变化时，通知更新；

当数据改变的时候，会触发Object.defineProperty - set函数，数据会遍历自己的 依赖收集器 subs，逐个通知 watcher，视图开始更新；


## Vue3.x响应式数据原理
Vue3.x改用Proxy替代Object.defineProperty

因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。

Proxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？

判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。

监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。


## Vue3.0 里为什么要用 Proxy API替代 defineProperty API？
1. defineProperty API 的局限性最大原因是它只能针对单例属性做监听。

Vue2.x中的响应式实现正是基于defineProperty中的descriptor，对 data 中的属性做了遍历 + 递归，为每个属性设置了 getter、setter。这也就是为什么 Vue 只能对 data 中预定义过的属性做出响应的原因

2. Proxy API的监听是针对一个对象的，那么对这个对象的所有操作会进入监听操作， 这就完全可以代理所有属性，将会带来很大的性能提升和更优的代码。

Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

3.响应式是惰性的

在 Vue.js 2.x 中，对于一个深层属性嵌套的对象，要劫持它内部深层次的变化，就需要递归遍历这个对象，执行 Object.defineProperty 把每一层对象数据都变成响应式的，这无疑会有很大的性能消耗。
在 Vue.js 3.0 中，使用 Proxy API 并不能监听到对象内部深层次的属性变化，因此它的处理方式是在 getter 中去递归响应式，这样的好处是真正访问到的内部属性才会变成响应式，简单的可以说是按需实现响应式，减少性能消耗。


## Proxy 与 Object.defineProperty 优劣对比
1. Proxy 可以直接监听对象而非属性
2. Proxy 可以直接监听数组的变化
3. Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的
4. Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改
5. Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利
6. Object.defineProperty 的优势如下

兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写

## vue中组件的data为什么是一个函数？而new Vue 实例里，data 可以直接是一个对象
我们知道，Vue组件其实就是一个Vue实例。

JS中的实例是通过构造函数来创建的，每个构造函数可以new出很多个实例，那么每个实例都会继承原型上的方法或属性。

Vue的data数据其实是Vue原型上的属性，数据存在于内存当中。Vue为了保证每个实例上的data数据的独立性，规定了必须使用函数，而不是对象。

因为使用对象的话，每个实例（组件）上使用的data数据是相互影响的，这当然就不是我们想要的了。对象是对于内存地址的引用，直接定义个对象的话组件之间都会使用这个对象，这样会造成组件之间数据相互影响。

使用函数后，使用的是data()函数，data()函数中的this指向的是当前实例本身，就不会相互影响了。

而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。

## vue中data的属性可以和methods中方法同名吗，为什么？
可以同名，methods的方法名会被data的属性覆盖；调试台也会出现报错信息，但是不影响执行；
原因：源码定义的initState函数内部执行的顺序：`props>methods>data>computed>watch`


## vue中created与mounted区别
在created阶段，实例已经被初始化，但是还没有挂载至el上，所以我们无法获取到对应的节点，但是此时我们是可以获取到vue中data与methods中的数据的；

在mounted阶段，vue的template成功挂载在$el中，此时一个完整的页面已经能够显示在浏览器中，所以在这个阶段，可以调用节点了；


## Vue中computed与method的区别
**相同点:**

如果作为模板的数据显示，二者能实现响应的功能，唯一不同的是methods定义的方法需要执行

**不同点：**

1.computed 会基于响应数据缓存，methods不会缓存；

2.diff之前先看data里的数据是否发生变化，如果没有变化computed的方法不会执行，但methods里的方法会执行

3.computed是属性调用，而methods是函数调用


## 虚拟DOM中key的作用
简单的说：key是虚拟DOM对象的标识，在更新显示时key起着极其重要的作用。

复杂的说：当状态中的数据发生了变化时，vue，react会根据【新数据】生成【新的虚拟DOM】，随后vue,React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：

- 旧虚拟DOM中找到了与新虚拟DOM相同的key
  + 若虚拟DOM中的内容没有变，直接使用之前的真是DOM
  + 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM

- 旧虚拟DOM中未找到与新虚拟DOM相同的key
  + 根据数据创建新的真实DOM，随后渲染到页面


## 用index作为key可能会引发的问题
- 若对数据进行：逆序添加/逆序删除等破坏顺序的操作，会产生没有必要的真实DOM更新，界面效果虽然没有问题，但是数据过多的话，会效率过低
- 如果结构中还包含输入类的DOM，会产生错误DOM更新，界面有问题
- 注意！如果不存在对数据的逆序操作，仅用于渲染表用于展示，使用index作为key是没有问题的


## Vue中watch用法详解
在vue中，使用watch来监听数据的变化

1. 监听的数据后面可以写成对象形式，包含handler方法，immediate和deep。
2. immediate表示在watch中首次绑定的时候，是否执行handler，值为true则表示在watch中声明的时候，就立即执行handler方法，值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。
3. 当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听。

```js
watch: {
  name: {
    handler(newName, oldName) {
    
    },
    deep: true,
    immediate: true
  }
} 
```


## vue中对mixins的理解和使用
mixins是一种分发 Vue 组件中可复用功能的非常灵活的方式。混合对象可以包含任意组件选项。当组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。

而mixins引入组件之后，则是将组件内部的内容如data等方法、method等属性与父组件相应内容进行合并。相当于在引入后，父组件的各种属性方法都被扩充了。


## vue中的插槽


## 为什么vue采用异步渲染
**原因**

Vue中的DOM操作都是异步执行，个人觉得原因有以下几点：

- 为了避免频繁操作DOM造成的性能消耗，如果每次数据发生变化都立即更新DOM的话，会造成频繁操作DOM。

- 避免重复的DOM操作，如果同一个 watcher 被多次触发，只会被推入到队列中一次。

**实现原理**

只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。 如果同一个 watcher 被多次触发，只会被推入到队列中一次。 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。 然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。 Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver和setImmediate，如果执行环境不支持，则会采用setTimeout(fn, 0)代替。


## Vue 的异步更新机制是如何实现的？


## $nextTick的理解


## Vue中常用的一些指令


## vue的自定义指令


## 你有写过自定义指令吗？自定义指令的应用场景有哪些？


## v-show和v-if指令的共同点和不同点


## 为什么避免v-if和v-for一起使用


## vue为什么在 HTML 中监听事件？


## Vue.set 改变数组和对象中的属性


## vm.$set(obj, key, val) 做了什么？


## 说说vue的生命周期的理解


## 第一次页面加载会触发哪几个钩子？


## Vue组件通信有哪些方式


## router和route的区别


## vue-router有几种钩子函数？


## vue-router路由跳转方式


## vue-router路由传参


## keep-alive了解吗


## Vuex是什么？怎么使用？


## 什么情况下使用 Vuex？


## Vuex和单纯的全局对象有什么区别？


## 为什么 Vuex 的 mutation 中不能做异步操作？


## axios 是什么，其特点和常用语法


## 对SSR有了解吗，它主要解决什么问题？


## Vue要做权限管理该怎么做？控制到按钮级别的权限怎么做？


## Vue项目前端开发环境请求服务器接口跨域问题


## 做过哪些Vue的性能优化？


## Vue3有了解过吗？能说说跟Vue2的区别吗？


## Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？





