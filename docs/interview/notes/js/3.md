## 如何变量提升

### 什么变量提升？
::: tip
变量提升（Hoisting）被认为是， Javascript中执行上下文 （特别是创建和执行阶段）工作方式的一种认识。在 ECMAScript® 2015 Language Specification 之前的JavaScript文档中找不到变量提升（Hoisting）这个词。
从概念的字面意义上说，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，但这么说并不准确。实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。
:::
通俗来说，变量提升是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的行为。变量被提升后，会给变量设置默认值为 undefined。 正是由于 JavaScript 存在变量提升这种特性，导致了很多与直觉不太相符的代码，这也是 JavaScript 的一个设计缺陷。虽然 ECMAScript6 已经通过引入块级作用域并配合使用 let、const 关键字，避开了这种设计缺陷，但是由于 JavaScript 需要向下兼容，所以变量提升在很长时间内还会继续存在。

在 ECMAScript6 之前，JS 引擎用 var 关键字声明变量。在 var 时代，不管变量声明是写在哪里，最后都会被提到作用域的顶端。 下面在全局作用域中声明一个num 变量，并在声明之前打印它：

```js
console.log(num)   // undefined
var num = 1
```
这里会输出 undefined，因为变量的声明被提升了，它等价于：
```js
var num
console.log(num)   // undefined
num = 1
```
可以看到，num 作为全局变量会被提升到全局作用域的顶端。

除此之外，在函数作用域中也存在变量提升：
```js
function getNum() {
  console.log(num);   // undefined
  var num = 1;
}
getNum();
```
这里也会输出 undefined，因为函数内部的变量声明会被提升至函数作用域的顶端。它等价于：

```js
function getNum() {
  var num;
  console.log(num);
  num = 1;
}
getNum();
```
除了变量提升，函数实际上也是存在提升的。JavaScript中具名的函数的声明形式有两种：

```js
//函数声明式：
function foo () {}
//变量形式声明： 
var fn = function () {}
```
当使用变量形式声明函数时，和普通的变量一样会存在提升的现象，而函数声明式会提升到作用域最前边，并且将声明内容一起提升到最上边。如下：
```js
fn();
var fn = function () {
  console.log(1);
};
// 输出结果：Uncaught TypeError: fn is not a function

foo();
function foo() {
  console.log(2);
}
// 输出结果：2
```
可以看到，使用变量形式声明fn并在其前面执行时，会报错fn不是一个函数，因为此时fn只是一个变量，还没有赋值为一个函数，所以是不能执行fn方法的。

### 为什么会有变量提升？

- 1. 提高性能

- 2. 容错性更好

### 变量提升导致的问题

- 1. 变量被覆盖

- 2. 变量没有被销毁

使用其他的大部分语言实现类似代码时，在 for 循环结束之后，i 就已经被销毁了，但是在 JavaScript 代码中，i 的值并未被销毁，所以最后打印出来的是 5。这也是由变量提升而导致的，在创建执行上下文阶段，变量 i 就已经被提升了，所以当 for 循环结束之后，变量 i 并没有被销毁。

### 禁用变量提升

### JS如何支持块级作用域

- 1. 创建执行上下文

- 3. 执行代码

### 暂时性死区