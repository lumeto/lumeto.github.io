## JS Web-API-DOM

DOM：Document Object Model （文档对象模型）

### DOM 本质
- DOM 是 树 结构
- DOM 本质是浏览器从 html 文件中解析出来的一棵树

### DOM 节点操作
```html
<div id="box"></div>
<div class="div"></div>
<div class="div"></div>
```
```js
// 方式1：通过 id 获取
  console.log(document.getElementById("box")); // <div id="box"></div>

  // 方式2：通过标签名获取
  const ElesByTagName = document.getElementsByTagName("div");
  console.log(ElesByTagName); // 集合 HTMLCollection [div#box, box: div#box]
  console.log(Array.isArray(ElesByTagName)); // 不是数组 false
  // 将集合转为数组的方法
  console.log(Array.isArray(Array.prototype.slice.call(ElesByTagName))); // true

  // 方法3：通过class获取
  console.log(document.getElementsByClassName("div")); // 集合
  // 方法4：通过 css 选择器方式获取
  console.log(document.querySelectorAll("div")); //集合
```
#### 获取 DOM 节点

#### property 和 attribute

`property` 和 `attribute` 形式都可以修改节点的属性（ 如 style ），但是对于新增或删除的自定义属性，能在html的dom树结构上体现出来的，就必须要用到attribute形式了。

两者都可能引起 DOM 重新渲染

### DOM 结构操作

#### 新增 / 插入节点
```html
<div id="divId">
  <p>old p element</p>
</div>
<div id="divId2"></div>
```
```js
const divEle = document.getElementById('divId');
// 新增子节点
const newPElement = document.createElement('p');
// 给节点插入文本
newPElement.innerHTML = 'new p element';
// 插入节点
divEle.appendChild(newPElement);
// 移动节点，将节点直接 appendChild 到想移动到的标签下
const divEle2 = document.getElementById('divId2');
divEle2.appendChild(newPElement);

```

#### 获取子元素列表和父元素列表
```html
<div id="divId">
  <p>old p element 1</p>
  <p>old p element 2</p>
  <p id="newPId">new p element</p>
</div>
```
```js
// 获取子元素列表
const divEle = document.getElementById('divId');
const childList = divEle.childNodes;  // 集合
// 注意，打印出的 childList 包括了文本标签
console.log(childList);
// 排除文本标签，Array.prototype.slice.call 可以转集合为数组
const newChildList = Array.prototype.slice.call(childList)
  .filter(child => child.nodeType === 1);
console.log(newChildList);

// 获取父元素列表
const newPEle = document.getElementById('newPId');
const parentNodeEle = newPEle.parentNode;
console.log(parentNodeEle);
```

#### 删除节点
```html
<div id="divId">
  <p>old p element 1</p>
  <p>old p element 2</p>
  <p id="newPId">new p element</p>
</div>
```
```js
// 需要通过id获取
const divEle = document.getElementById('divId');
const childList = divEle.childNodes;  // 集合
const newChildList = Array.prototype.slice.call(childList)
  .filter(child => child.nodeType === 1);
// 删除节点
divEle.removeChild(newChildList[2]);
```

### DOM 性能
DOM 操作非常耗费性能，应该尽可能避免频繁的 DOM 操作

**如何解决：** 

对 DOM 操作进行缓存，将频繁操作改为一次性操作
#### DOM 查询做缓存
```js
// 不缓存 DOM 查询结果
for(let i = 0; i < document.getElementsByTagName('p').length; i += 1) {
  // 每次循环，都会计算 p 标签的 length，导致频繁进行 DOM 查询
}

// 缓存 DOM 查询结果
const len = document.getElementsByTagName('p').length;
for(let i = 0; i < len; i += 1) {
  // 缓存 length，只进行一次 DOM 查询
}

```

#### DOM 插入做缓存
```html
<ul id="list"></ul>
```
```js
  const ulEle = document.getElementById('list');
  const count = 10;   

  // 1. 不缓存 DOM 插入，每次循环都插入新的 li，当 count 很大时，会很耗费性能
  for(let i = 0; i < count; i += 1) {
    const liEle = document.createElement('li');
    liEle.innerHTML = `item - li - ${i + 1}`;
    ulEle.appendChild(liEle);
  }

  // 2. 缓存 DOM 插入，每次循环都先插入 frag 中，循环结束后再一次性插入 ulEle 中
  // 创建一个文本片段，此时没有插入的DOM渲染中（也可以用普通标签代替）
  const frag = document.createDocumentFragment();
  for(let i = 0; i < count; i += 1) {
    const liEle = document.createElement('li');
    liEle.innerHTML = `item - li - ${i + 1}`;
    // 先插入文档片段中，不会触发 DOM 重新渲染
    frag.appendChild(liEle);
  }
  ulEle.appendChild(frag);

```

### 相关面试题
如何进行DOM性能优化
- 对DOM查询做缓存
- 将频繁操作改为一次性操作

