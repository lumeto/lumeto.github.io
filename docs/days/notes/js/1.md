## 变量类型和计算

### 值类型
```JS
let a = 100
let b = a
a = 200
console.log(b) // 100
```
#### 分析
栈是存放变量的地方，首先定义一个变量a等于100，然后定义一个变量b等于a，b等于100，再将a的值改为200，可以看到b的值没有改变,因为b和a是不一样的
#### 常见值类型
字符串、布尔值、数字、Symbol
```JS
let a // undefind
const s = 'abc'
const n = 100
const b = true
const s = Symbol('s')

```

### 引用类型
```JS
let a = {age: 20}
let b = a
b.age = 21
console.log(a.age) // 21
```
#### 深入分析
一个对象或者一个JSON 可能会非常非常大
1. 如果和值类型一样存储，占用太大的存储空间
2. 复制的时候可能会复制的非常慢
  
#### 常见引用类型
```JS
const obj = {x: 100}
const arr = ['a', 'b', 'c']
const n = null // 特殊的引用类型，指针指向为空的地址
// 特殊引用类型，但并不用于存储数据，所以没有 ‘拷贝、辅助函数’这一说
function fn (){}
```

### typeof 运算符
#### typeof 识别所有值类型
所有的值类型
```JS
let a // undefind
// type a  undefind

const s = 'abc'
// type s  string

const n = 100
// type n  number

const b = true
// type b boolean

const s = Symbol('s')
// type b  symbol

```
#### 识别函数
```JS
 console.log(typeof console.log);   // function
 console.log(typeof function () {});   // function
```
#### 判断是否时引用类型（不可再细分）
```JS
console.log(typeof null);   // object
console.log(typeof []);   // object
console.log(typeof {});   // object
```
> null 数组 对象 ，使用typeof是无法判断具体类型的 

### 变量计算
#### 字符串拼接
```JS
const a = 100 + 10;
const b = 10 + "10";
const c = true + 10;
const d = true + "10";
console.log("a", a); // a 110
console.log("b", b); // b 1010
console.log("c", c); // c 11
console.log("d", d); // d true10
```

#### `==` 运算符
```JS
console.log(100 == "100");   // true
console.log(0 == "");   // true
console.log(0 == false);   // true
console.log("" == false);   // true
console.log(null == undefined);   // true
```
> 除了 == null 之外，其他的一律用 === ， 如：
```JS
const obj = {
  a: 100,
};
if (obj.b == undefined) {
  console.log("aa");
}
//等同于 if(obj.b === null || obj.b === undefined){}
```

#### if 语句和逻辑运算
两步非运算!! 得到的结果
#### truly 变量： !!a === true 的变量
```JS
const a = true;
console.log("a", !!a);  // true

console.log(0 === true); // false
console.log(!0 === true); // true
console.log(!!0 === true); // false

console.log(null === true); // false
console.log(!null === true); // true
console.log(!!null === true); // false

console.log(undefined === true); // false
console.log(!undefined === true); // true
console.log(!!undefined === true); // false

console.log(false === true); // false
console.log(!false === true); // true
console.log(!!false === true); // false
```
#### falsely 变量： !!a === false 的变量
```JS
console.log(0 === false); // false
console.log(!0 === false); // false
console.log(!!0 === false); // true

console.log(null === false); // false
console.log(!null === false); // false
console.log(!!null === false); // true

console.log(undefined === false); // false
console.log(!undefined === false); // false
console.log(!!undefined === false); // true

console.log(false === false); // true
console.log(!false === false); // false
console.log(!!false === false); // true
```

### 变量类型相关的面试题

#### typeof 能判断哪些类型

- 识别所有值类型
- 识别函数
- 判断是否是引用类型（不可再细分）
  
#### 合适使用 === 何时使用 ==
> 除了 == null 之外，其他的一律用 === ， 如：
```JS
const obj = {
  a: 100,
};
if (obj.b == undefined) {
  console.log("aa");
}
//等同于 if(obj.b === null || obj.b === undefined){}
```

#### 值类型和引用类型的区别
存储位置不一样,值类型的变量是存放在栈区的,引用类型的变量也是存放在栈区的，不同的是，引用类型在栈区中存放的是变量标识符以及变量所对应值得引用地址，而变量所对应的值被存放在堆区中.

`实例：`
```JS
const obj1 = { x: 100, y: 200 };
const obj2 = obj1;
let x1 = obj1.x;
obj2.x = 101;
x1 = 102;
console.log(obj2);  // 101
```

