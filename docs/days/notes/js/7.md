## 原型和原型链

### 原型
::: tip
1. 所有引用类型都有一个`__proto__`(隐式原型)属性，属性值是一个普通的对象
2. 所有函数都有一个`prototype`(原型)属性，属性值是一个普通的对象
3. 所有引用类型的`__proto__`属性指向它构造函数的prototype
:::
   
```js
let arr = [1, 2, 3];
if (arr.__proto__ === Array.prototype) {
  console.log("ok");  // ok
} else {
  console.log("no");
}

//打印结果 ok
```

### 原型链
::: tip
当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的`__proto__`隐式原型上查找，即它的构造函数的`prototype`，如果还没有找到就会再在构造函数的`prototype`的`__proto__`中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。
:::
```js
function Parent(name) {
  this.name = name;
}

var child = new Parent("lume");

console.log(child.name); // lume

console.log(child.a); // undefined


```
::: tip
1. 一直往上层查找，直到到null还没有找到，则返回undefined
2. Object.prototype.__proto__ === null
3. 所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象
:::

<hr/>  
为了更好的理解，找了一张原型链图

![原型链](/images/yx.png)


### Object-重点
我们先看一段代码:
```js
function Person(name) { // 1
  this.name = name;
}

Person.prototype.sayName = function (welcome) { // 5
  console.log(welcome, this.name);
};

var person1 = new Person("lume"); // 9
person1.sayName("Hello"); // 10

```
在执行这段代码之前，有个东西是一直存在的，就是有些人所说的“原型的原型”。如下图所示，我们用圆形代表`function`，用方形代表`object`:

![原型链](/images/yuanxing-01.png)

左边的圆形是`Object`构造函数，就是我们一般使用`var obj = new Object()`时最普普通通的的构造函数。

右边的方形是`Object`的`prototype` 。

左边有一个箭头指向右边，意味着`Object`有一个属性叫做`prototype`，这个属性指向的是右边的那个方块，而向左指的箭头，意味着右边方块的`constructor`属性是左边的`Object`构造函数。

::: tip
这些东西在上面程序运行之前就一直存在的
:::


### 构造函数-重点
好的，我们开始看第一行代码，运行第一行代码之后，会生成一个叫`Person`的构造函数，而这个构造函数的`prototype`属性，指向的就是它的`prototype`，如下图方块所示：

![原型链](/images/yuanxing-02.png)

`Person`与`Person.prototype`之间的关系，与Object和Object.prototype类似，不同的是，`Person.prototype`会通过proto指向`Object.prototype`。

接下来看第5行代码：我们在`Person.prototype`上面添加一个sayName方法，如上图所示，`Person.prototype`这个方块中有sayName方法。


### new调用构造器-重点
最后来看第9行代码，这行代码中，我们new了一个Person的实例，使用new这个关键字的时候，JS编译器会做四件事情：
1. 创建一个新的空的对象
2. 把这个对象链接到原型对象上，将构造函数的作用域赋给新对象（因此this就指向了这个新对象）
3. 执行构造函数中的代码（为这个新对象添加属性）
4. 如果这个函数有返回值，则返回；否则，就会默认返回新对象
   
![原型链](/images/yuanxing-03.png)
如下图所示，我们先创建一个person1的空对象，然后把person1通过proto指向原型对象，指向构造函数中的代码，person1就获得了一个叫做name的属性，最后返回。

我们最后运行第10行代码：`person1.sayName('Hello')`;

person1上有sayName这个方法么？没有，那么就顺着person1的proto向上找，找到`Person.prototype`。`Person.prototype`上面有sayName方法么？有的，那么执行这个方法。这个方法内部使用了this.name，那么这个this的指向是什么么？我们需要看sayName的call site，是person1调用的sayName，隐式调用，this就指向person1，而person1的name就是lume。

是不是觉得很神奇，最后调用时候使用的属性和方法都是我们希望使用的那个，person1.sayName('Hello')看似很容易理解，JS初学者都能很容易说出最后输出结果，但是这其中的过程，恐怕只有理解了原型和原型链才能真正说明白。

明白了这些之后，我们看两个相等关系：
```js
console.log(Person === Person.prototype.constructor);
console.log(person1.__proto__ === Person.prototype);
```

  
  