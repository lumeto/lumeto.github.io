## css响应式布局与媒体查询
这篇只介绍这两种布局方式，如想了解更多可以查看上一遍文章 <a href="/days/notes/css/3">常用的css布局</a>

### 什么是响应式布局
> 响应式布局（respond layout）是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端（手机、平板、pc电脑、手表） ——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。

为什么要有响应式布局？

- 在移动互联日益成熟的时候，在PC端开发的网页已经无法满足移动设备的要求。
- 通常的做法是针对移动端单独做一套特定的版本。
- 如果终端越来越多，那么需要开发的版本就会越来越多（大屏设备的普及）
- **响应式布局** ：一个网站能够兼容多个终端（节约开发成本）

**优点：**
面对不同分辨率设备灵活性强

能够快捷解决多设备显示适应问题

**缺点：**
兼容各种设备工作量大，效率低下

代码累赘，会出现隐藏无用的元素，加载时间加长

其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果

一定程度上改变了网站原有的布局结构，会出现用户混淆的情况

响应式开发现状：
- 如果已经存在PC的网站了，那么一般不会使用响应式开发，而是针对移动端再开发一套系统（比如京东、淘宝）
- 在新建站点 上采用响应式开发的越来越多。
- 在国内，响应式开发还不是特别的流行。但响应式开发是大势所趋，会越来越流行。
  
**响应式开发与移动web开发的比较**
|   开发方式      | 移动web开发+pc开发 |  响应式开发  | 
| -----------  | ----------- | -----------  |
| 引用场景      |一般已经有了PC端网站，只需要端独开发移动端网站即可    |   针对一些新建网站，并且要求适配移动端   |
| 开发   | 针对性强，开发效率高   | 兼容各种终端，效率低  |
| 适配   | 只能适配移动端或者PC端，pad上体验比较差    | 可以适配各种终端  |
| 效率   | 代码简洁，加载快    |  代码相对复杂，加载慢  |

### 媒体查询
> 媒体查询（Media Query）是CSS提出来的一个新的属性，通过媒体查询可以查询到screen的宽度，从而指定某个宽度区间的网页布局。

| 分类      | 宽度范围 |
| ----------- | ----------- |
| 大屏设备      | >1200px     |
| 中屏设备   | 992px~1200px   |
| 小屏设备   | 768px~992px    |
| 超小屏设备   | < 768px      |

媒体查询语法：
```css
/*查询屏幕*/
@media screen and 条件 {
}

/*条件的写法*/
/*min-width:只要屏幕宽度超过这个值的设备样式就能生效*/
/*max-width:只要屏幕宽度小于这个值的设备样式就能生效*/
@media screen and (min-width: 1200px) {
  .container {
    width: 1170px;
    background-color: red;
  }
}

@media screen and (min-width: 992px) and (max-width: 1200px) {
  .container {
    width: 970px;
    background-color: blue;
  }
}

@media screen and (min-width: 768px) and (max-width: 992px) {
  .container {
    width: 750px;
    background-color: yellow;
  }
}

@media screen and (max-width: 768px) {
  .container {
    width: 100%;
    background-color: green;
  }
}

```

弊端：现在只有一个div，要做一套响应式布局，就需要如此多的代码，非常的麻烦，因此我们会更多的借助一些响应式的框架，比如
<a href="https://getbootstrap.com/docs/5.1/layout/grid/" target="_blank">bootstrap</a>。

### 终极解决方案 postcss-px-to-viewport-8-plugin
安装插件
```javascript
yarn add -D postcss-px-to-viewport-8-plugin
// or npm add -D postcss-px-to-viewport-8-plugin
```
创建postcss.config.js 配置文件
```javascript
module.exports = {
  plugins: {
    'postcss-px-to-viewport-8-plugin': {
      unitToConvert: 'px', // 需要转换的单位，默认为"px"
      viewportWidth: 750, // 设计稿的视口宽度
      unitPrecision: 5, // 单位转换后保留的精度
      propList: ['*'], // 能转化为vw的属性列表
      viewportUnit: 'vw', // 希望使用的视口单位
      fontViewportUnit: 'vw', // 字体使用的视口单位
      selectorBlackList: [], // 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。
      minPixelValue: 1, // 设置最小的转换数值，如果为1的话，只有大于1的值会被转换
      mediaQuery: false, // 媒体查询里的单位是否需要转换单位
      replace: true, //  是否直接更换属性值，而不添加备用属性
      exclude: [/node_modules/], // 忽略某些文件夹下的文件或特定文件，例如 'node_modules' 下的文件
      include: [/src/], // 如果设置了include，那将只有匹配到的文件才会被转换
      landscape: false, // 是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape)
      landscapeUnit: 'vw', // 横屏时使用的单位
      landscapeWidth: 1338, // 横屏时使用的视口宽度
    },
  },
};
```
- 对js动态css无效,所以要动态改变css展示效果的话，要使用静态的class定义变化样式
-  Vant组件的设计稿尺寸是375px，可用通过覆盖:root下的Vant的css变量中px单位的方式，对Vant组件做适配
- **可以直接使用像素px ，插件将自动转为 vw单位（100px = 13.33333vw）, 从此可以弃用 rem 适配方案了** 。

