## 实现 call()

### call() 函数的简介
- call() 函数中的第一个参数表示：想让 this 指向的对象 (obj)
- call() 函数中的第二及以后参数表示：传进去都是函数的参数

#### call 函数的用法
```js
fn.call(obj,1,2)
```

#### call 函数的功能
- 其一、让函数立执行
- 其二、可改变 this 的指向
- 其三、可实现继承问题

### call() 函数的调用过程
```js
var person = {
  fullName: function (txt) {
    console.log(txt + this.firstName + " " + this.lastName);
  },
};
var person1 = {
  firstName: "John",
  lastName: "Doe",
};
person.fullName.call(person1, "Hello, "); // 输出"Hello, John Doe"
```
**上面的call做了这几件事情，分为三步：**

1. `person.fullName.call(person1)`这个函数调用时候的`this`指向变了，如果只是使用`person.fullName()`的话，是隐式绑定，`this`应该指向`person`。但是使用`person.fullName.call(person1)`之后变成了显式绑定，`this`绑定传入的第一个参数，即`person1`。
2. 从call函数传入的第二个参数开始，作为`person.fullName`的参数传入。
3. 不更改`person`和`person1`的任何属性和方法。`person`这一边，如果你再次调用`person.fullName()`，不会打印任何和`person1`相关的信息；而`person1`这一边，并没有增加或者更改它自身的任何方法。

### 模拟实现 call()
```js
var person = {
  fullName: function (txt) {
    console.log(txt + this.firstName + " " + this.lastName);
  },
};
var person1 = {
  firstName: "John",
  lastName: "Doe",
};
 // 原生 js call()
// person.fullName.call(person1, "Hello, "); // 输出"Hello, John Doe"
```
```js
// 自定义 myCall()

Function.prototype.myCall = function (context) {
  // 其中 context 参数是指：改变 this 指向，而待指向的的参数值(如：obj)；
  // 此时是在 Function 的原型链上来添加 myCall() 函数, 那么此时该函数中的 this 指向的是：调用该 myCall() 方法的实例或函数；

  // 处理参数(即：实参)；
  var args = [...arguments].slice(1);
  // 将 arguments 的值从第二个截取后，放到 args 的数组里；
  // 该操作是将传入的实参值转化成数组，以待后面使用；

  context = context || window;
  // 当传的值为 null 或没传值时(均为：false)，此时 context 的值为：Window；
  // 当传值时(为：true)，此时的 context 的值为：context;

  context.fn = this;
  // 此时 this 指向的是：将来调用 myCall 方法的那个函数；
  // 而又由于 context 调用 fn 这个属性是指向 this, 因此此时的 this 就指向了 context;  那么此时就完成了 this 指向 context 的目的；
  // 该操作是：让将来调用 myCall 方法的那个函数，封装到 context 的一个属性中去(即：context.fn)；
  // 那么此时的 context.fn 就代表的是调用 myCall 方法的那个函数，它是一个函数；

  var r = context.fn(...args);
  // 该操作是：调用 context.fn() 函数，也就是调用了 '调用 myCall' 的函数；
  // 并传参为：'...args', 也就是将 args 数组中的值展开作为参数传入函数中；
  // 此时也就完成了，将 this 的指向为：context;     且还运行了 '调用 myCall' 的函数，并将参数传进去； (即：已经实现了 call() 函数的功能)；

  return r;
  // 然后再将操作后的值返回；
};
```

```js
person.fullName.myCall(person1, "Hello, ");   // Hello, John Doe
```


#### 自定义myCall实现继承
```js
Function.prototype.myCall = function (context) {
  context = context || window;
  var args = [...arguments].slice(1); // 参数
  context.fn = this;
  var r = context.fn(...args);
  return r;
};

function Person(name, age) {
  this.name = name;
  this.age = age;
}
function Student(name, age, grade) {
  Person.myCall(this, name, age, grade);
  this.grade = grade;
}

//创建一个学生类
var student = new Student("zhangsan", 21, "一年级");

console.log(student.name);  // zhangsan
console.log(student.age);  // 21
```

