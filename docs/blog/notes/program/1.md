## 手写浅/深拷贝

> 对象拷贝，简而言之就是将对象再复制一份，但是，复制的方法不同将会得到不同的结果。

### 什么是浅拷贝/深拷贝
所以浅拷贝和深拷贝（也叫浅复制和深复制）的概括解释为：

对基本类型变量，浅拷贝是对值的拷贝，没有深拷贝的概念。
对引用类型来说，浅拷贝是对对象地址的拷贝，并没有开辟新的栈，复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，另外一个对象的属性也会改变， 而深拷贝则是开辟新的栈。

****
```js
let a = [0, 1, 2, 3, 4],
  b = a;
console.log(a === b);
a[0] = "小李";
console.log(a, b);
//  ['小李',1,2,3,4]
//  ['小李',1,2,3,4]
```
当修改a数组里面的值，也会修改b里面的值,因为它们指向同一块地址。

### 将浅拷贝转换成深拷贝
在实际的项目开发过程中，我们在多数情况下不希望将对象进行浅拷贝，因为值会相互影响，容易出错。这里主要讲js中的Array和Object类型从浅拷贝转换成深拷贝。

#### Array的深拷贝

##### 通过slice方法
slice()操作数组时，不会对原数组有影响，会产出一个新的数组。
```js
let arr1 = [1, 42, 5, 6];
let arr2 = arr1.slice();
arr2[0] = "小李";
console.log(arr1); // [1, 42, 5, 6]
console.log(arr2); // ['小李', 42, 5, 6]
```
数组arr2的改变未引起arr1的变化

##### 通过concat方法
数组的concat()方法，能够连接两个数组，同样不会改变原来的数组。用一个空数组连接另一个数组，即可实现深拷贝。
```js
let arr1 = ["1", "2", "3"];
let arr2 = [].concat(arr1);
arr1[2] = "333";
console.log(arr1); // ['1', '2', '333']
console.log(arr2); // ['1', '2', '3']
```

##### 通过ES6语法
ES6语法中的 …， 我经常在数组的深拷贝中用到。
```js
let arr1 = [1, 2, 3];
let arr2 = [...arr1];
arr1[0] = 333;
console.log(arr1); // [333, 2, 3]
console.log(arr2); // [1, 2, 3]
```

##### 通过Array.from方法
Array.from()方法能从一个类似数组或可迭代对象中返回一个新的数组实例。通过Array.from()方法能获取到一个数组的深拷贝。
```js
let arr1 = [1, 2, 3];
let arr2 = Array.from(arr1);
arr1[1] = 333;
console.log(arr1); // [1, 333, 3]
console.log(arr2); // [1, 2, 3]
```

#### Object的深拷贝
##### 通过Object.assign()方法
::: tip
ES6的Object.assign() Object.assign(target, …sources)用于对象的合并，将源对象中的所有可枚举属性，复制到目标对象中，并返回合并后的目标对象。后来的源对象的属性值，将会覆盖它之前的对象的属性。
:::
```js
let xiaoli = {
  name: "小李",
  age: 18,
  height: 160,
};
let xiaozhang = Object.assign({}, xiaoli);
xiaoli.age = 28;

console.log(xiaoli); // {name: "小李", age: 28 ,height: 160}
console.log(xiaozhang); // {name: "小李" ,age: 18 ,height: 160}
```

#### 万能转换器（只对Array和Object）
前面讲解了 Array和Object的深拷贝方法，但是对于有更深层次的结构关系（数组套数组 数组套对象 对象套对象等），上面的方法就失灵了，可以看下面的例子。
```js
let arr1 = [{ name: "小张" }, { name: "小李" }];
let arr2 = [...arr1];
arr1[0].name = "小赵";
console.log(arr1);
console.log(arr2);
```
![拷贝](/images/qkb.png)

**万能转换器 JSON.parse(JSON.stringify(obj))深拷贝已有对象，它可以深拷贝多层级的，不用担心嵌套问题。**
- JSON.stringfy() 将对象序列化成json对象
- JSON.parse() 反序列化——将json对象反序列化成js对象

**JSON.stingify(obj)将js中的对象转换成JSON**
```js
let obj = {
  name: "小李",
};
console.log(obj);  // 对象
console.log(JSON.stringify(obj));  // json字符串
```
![拷贝](/images/bk2.png)

第一个是对象，name没有双引号括起来。第二个是json字符串，其中，name用双引号括起来了

`JSON.parse()`将`json`字符串解析成对象
```js
let obj = {
  name: "西游记",
};
console.log("obj: ", obj);
console.log("对象 to str: ", JSON.stringify(obj));

let str = JSON.stringify(obj);
console.log("--------------");
console.log(str);
console.log("str to obj: ", JSON.parse(str));
```

### 相关面试题
递归-实现深拷贝
```js
var obj1 = {
  age: 20,
  name: "xxx",
  address: {
    city: "beijing",
  },
  arr: ["a", "b", "c"],
};
var obj2 = deepClone(obj1);
obj2.address.city = "上海";

console.log(obj2);
console.log(obj1);

function deepClone(obj = {}) {
  if (typeof obj !== "object" || obj == null) {
    return obj;
  }
  let result;
  if (obj instanceof Array) {
    result = [];
  } else {
    result = {};
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = deepClone(obj[key]);
    }
  }
  return result;
}

```