## 作用域与闭包

### JS中的作用域
在 `es6` 出现之前JS中只有`全局作用域`和`函数作用域`，`没有块级作用域`，即 JS 在函数体内有自己的作用域，但是如果不是在函数体的话就全部都是全局作用域。比如在 if、for 等有 {} 的结构体，就不会具备自己的作用域，在这些结构体内声明的变量将会是全局变量。由此可能导致一些问题，下面代码示例：
```js
var tmp = new Date();
function f() {
  console.log(tmp);
  //即使没有运行到下面的代码，该变量声明也被提升了。因为变量声明是在编译阶段就被运行的，而不是代码运行阶段
  var tmp = "hello world";
}
f(); // undefined  由于变量提升，导致内层的tmp变量覆盖了外层的tmp变量
```
```js
for (var i = 0; i < 5; i++) {
  console.log(i);  // 0,1,2,3,4
}
console.log(i); // 5  用来计数的循环变量泄露为全局变量。
```

在 es6 中引入的块级作用域就解决了这些问题。通过 let、const 引入块级作用域后：

```js
function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5   无法访问到块级作用域里的变量
}
f1();
```

#### 函数内部变量的作用域取决于函数声明的位置
编程语言的作用域规则有动态作用域和词法作用域，词法作用域的指的是函数和变量的作用域由`声明时所处的位置决定`，JS使用的就是词法作用域。

在JS中，调用函数时，函数内部的变量的作用域由`函数声明时所处的位置决定`，而不是调用的位置。
```js
var a = "window";
var fn = function () {
  console.log(a);
};
var fn1 = function () {
  var a = "else";
  fn(); 
};
fn1(); //输出 'window'
```
**但是 JS 中的 this 指针并不遵守词法作用域，而是取决于函数的调用方式。(`call()`,`apply()`...)**


#### 块级作用域
先看下面代码：
```html
 <ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
    <li>4</li>
    <li>5</li>
    <li>6</li>
  </ul>
```
```js
var liList = document.getElementsByTagName("li");
for (var i = 1; i <= liList.length; i++) {
  liList[i].onclick = function () {
    alert(i); // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5
  };
}
```
因为 javascript 没有块级作用域，作用每次 onclick 访问 i 时，因为没有块级作用域的 i，所以只能查找全局作用域的 i，此时全局 i 是6，所以每次输出 6。

而如果把 i 换成是 let 声明，此时就有块级作用域，每次访问的 i 都是块级作用域的 i，就能依次输出正确结果。


### 全局变量和局部变量
JS中的变量只有两种：全局变量和局部变量。函数体外声明的变量，称为全局变量。 函数内部使用 var 声明的变量，称为局部变量。 
```js
//函数内部可以直接读取全局变量。
var n = 99;
function f1() {
  console.log(n);
}
f1(); // 99
```
```js
//但是在函数外部无法读取函数内的局部变量，因为函数内部的变量在函数执行完毕以后就会被释放掉
function f1() {
  var n = 999;
}
f1();
console.log(n); //报错： n is not defined
```
**注意：在函数内部声明变量的时候，一定要使用 var、let、const 命令。否则的话实际上是声明了一个全局变量！**
```js
function f1() {
  n = 99;
}
f1();
console.log(n); // 99
```
而要想访问到局部变量，那么就可以使用闭包。

### 闭包的概念
闭包就是能够读取其他函数内部变量的函数。

在 es6之前，JavaScript中的变量的作用域只有两种：全局作用域和函数作用域。函数内部可以直接读取全局变量，但是在函数外部就无法读取函数内的局部变量。要想从外部读取函数内的局部变量就要用到闭包。
```js
function f1() {
  var n = 99;
  function f2() {
    console.log(n);
  }
  return f2;
}
var result = f1();
result(); // 99
console.log(n); //报错  n is not defined
```
**闭包可以形象地理解成：将一个变量包裹起来了，在函数外部也可以访问该变量**，但请注意，闭包只是让我们在函数外部可以使用另一个函数来访问前一个函数内部的变量，但是该变量并不是变成了全局变量，直接访问该变量会报错。


### 闭包的作用
1. 可以读取函数内部的变量
2. 让这些变量的值始终保持在内存中

#### 让这些变量的值始终保持在内存中
```js
function f1() {
  var n = 99;
  add = function () {
    n += 1;
  };
  function f2() {
    console.log(n);
  }
  return f2;
}
var result = f1();
result(); // 99
add();
result(); // 100
```
在上面的代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是99，第二次的值是100。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。（如果n是一个需要很费时的操作才能得到的值的话就会作用明显，而且可以把局部变量驻留在内存中，避免使用全局变量）

这段代码中另一个值得注意的地方，就是"add=function(){n+=1}"这一行，add是一个全局变量，这个函数本身也是一个闭包，因为该函数的存在我们可以在函数外部对函数内部的局部变量进行操作。

#### 减少全局变量的污染
所有的变量声明时如果不加上var等关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量、造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。

闭包有一个作用就是能减少全局变量的使用，因为使用闭包可以在外部访问函数内部的变量，而该变量也只能通过函数访问，并不是一个全局变量。

#### 实现封装
```js
var person = function () {
  //变量作用域为函数内部，外部无法访问    
  var name = "default";
  return {
    getName: function () {
      return name;
    },
    setName: function (newName) {
      name = newName;
    }
  }
}();
console.log(person.name);      //直接访问，结果为undefined    
console.log(person.getName()); // default
person.setName("abruzzi");
console.log(person.getName()); // abruzzi
```
上面的代码给对象 person 创建了私有变量 name，又对外提供了获取的方法，对外封装了一个对象并且不可直接访问和操作，只可通过对象定义的方法进行操作，增加了安全性。

上面的代码就是典型的自执行函数和闭包结合使用的示例，立即执行函数和闭包其实并没有什么关系，只是两者会经常结合在一起使用而已，但两者有本质上的区别。两者也有一个共同的优点就是能减少全局变量的使用。

#### 实现继承
下面定义了Person，它就像一个类，我们new一个 Person 对象，访问它的方法。下面我们定义了Jack，继承自 Person，并添加自己的方法，Jack 继承了 Person。
```js
function Person2() {
  var name = "default";
  this.age = 12;
  return {
    getName: function () {
      return name;
    },
    setName: function (newName) {
      name = newName;
    }
  }
};
var p = new Person2();
console.log(p.age);
p.setName("Tom");
console.log(p.getName());
var Jack = function () {};
//继承自Person
Jack.prototype = new Person2();
//添加私有方法
Jack.prototype.Say = function () {
  console.log("Hello,my name is Jack");
};
var j = new Jack();
j.setName("Jack");
j.Say();
console.log(j.getName());
```

#### 闭包在实际开发中的使用
闭包在实际开发中的一般都是用来替代全局变量，避免造成变量污染。
```js
function isFirstLoad(){
    var list=[];
    return function(option){
        if(list.indexOf(option)>=0){ //检测是否存在于现有数组中，有则说明已存在
            console.log('已存在')
        }else{
            list.push(option);
            console.log('首次传入'); //没有则返回true,并把这次的数据录入进去
        }
    }
}
var ifl=isFirstLoad();
ifl("zhangsan");  //首次传入
ifl("lisi");      //首次传入
ifl("zhangsan");  //已存在
```
可以看到，如果外界想访问 list 变量，只能通过我定义的函数isFirstLoad来进行访问。我对想访问 list 的外界只提供了 isFirstLoad 这一个接口。至于怎么操作_list，我已经定义好了，外界能做的就只是使用我的函数，然后传几个不同的参数罢了。并且 list 变量并不是全局变量，所以就避免了变量污染。

### 闭包的危害

#### 可能导致内存泄露
由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露（即己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，将导致程序运行速度减慢）。解决方法是，在退出函数之前，将外部的引用置为 null。

#### 可能不小心修改掉私有属性
闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，闭包可能会修改掉父函数的私有属性。

### 相关面试题
闭包的用处在一道面试题中常常能看到：在 setTimeout 中依次输出 0 1 2 3 4
```js
//下面的代码全部输出 5
for (var i=1; i<5; i++) { 
    setTimeout( function timer() {
        console.log(i);
    }, i*1000 );
}

//下面会依次输出 0 1 2 3 4
for (var i=1; i<5; i++) { 
    (function(i) {
        setTimeout( function timer() {
            console.log(i);
        }, i*1000 );
    })(i)
}
```
